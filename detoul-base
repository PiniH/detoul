#!/bin/bash

exit_code="0"

cd "$GIT_WD"

have_uncommitted_changes="$(git status --porcelain | wc -l)"
if [ "$have_uncommitted_changes" != "0" ]; then
  git stash -u >/dev/null 2>&1
fi

quit() {
  git checkout "$DETOUL_ORIG_BRANCH" >/dev/null 2>&1
  
  if [ "$have_uncommitted_changes" != "0" ]; then
    git stash pop --index >/dev/null 2>&1
  fi
  
  exit "$exit_code"
}

fail() {
  exit_code="1"
  quit
}

autocomplete() {
  branch_name="$(git branch -a | sed -e 's/remotes\/[[:alnum:]]\+\///g' | cut -c3- | grep "^$1" | head -n 1)"
  if [ "$branch_name" == "" ]; then
    echo "$1"
  else
    echo "$branch_name"
  fi
}

checkout() {
  echo "Checking out '$branch'..."
  (
    git checkout "$branch" &&
      git branch -f "$DETOUL_BRANCH" &&
      git checkout "$DETOUL_BRANCH"
  ) >/dev/null 2>&1 || fail
  base_branch="$branch"
}

take() {
  if [ "$base_branch" == "" ]; then
    checkout
  else
    if [ "$1" == "" ]; then
      echo "Taking '$branch'..."
    else
      echo "Taking '$branch' ($1)..."
    fi
    source_branch="$(git show-ref "$branch" | cut -d' ' -f1 | head -n 1)"
    (
      git checkout "$branch" &&
        git checkout "$DETOUL_BRANCH" &&
        git rebase --onto "$DETOUL_BRANCH" "$base_branch" "$source_branch" &&
        git checkout "$DETOUL_BRANCH" &&
        git reset --hard HEAD@{1}
    ) >/dev/null 2>&1 || fail
    
    if [ "${1/squash}" != "$1" ]; then
      message="$2"
      if [ "$message" == "" ]; then
        message="$branch"
      fi
      (
        git reset --soft "$DETOUL_BRANCH@{1}" &&
          git commit -m "$message"
      ) >/dev/null 2>&1 || fail
    fi
    
    if [ "${1/rebase}" == "$1" ]; then
      (
        bash -c "git filter-branch --parent-filter 'cat; echo \"-p $source_branch\"' -f HEAD~..HEAD"
      ) >/dev/null 2>&1 || fail
    fi
  fi
}

pick() {
  if [ "$base_branch" == "" ]; then
    branch="${command[1]}"
    checkout
  else
    echo "Picking '${command[1]}'..."
    (
      git cherry-pick "${command[1]}"
    ) >/dev/null 2>&1 || fail
  fi
}

base_branch=""

while read -r line; do
  if [ "$line" == "" ]; then
    continue
  fi
  command=($line)
  branch="$(autocomplete "${command[1]//\*/.*}")"
  case "${command[0]}" in
    checkout)
      checkout
      ;;
    rebase)
      take rebase
      ;;
    rebase-squash)
      take rebase-squash "$(echo "$line" | sed -e 's/^rebase-squash\s\+[[:graph:]]\+\s*//')"
      ;;
    take)
      take
      ;;
    take-squash)
      take squash "$(echo "$line" | sed -e 's/^take-squash\s\+[[:graph:]]\+\s*//')"
      ;;
    pick)
      pick
      ;;
    exec)
      echo "Executing '${line/exec /}'..."
      bash -c "${line/exec /}" || fail
      ;;
  esac
done

quit
